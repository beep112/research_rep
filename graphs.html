<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HRA Graph Viewer</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; }
    header { background: #0b3d91; color: white; padding: 12px 16px; }
    h1 { font-size: 18px; margin: 0; }
    .tabs { display: flex; gap: 8px; background: #f3f4f6; padding: 8px 8px 0; }
    .tab { padding: 8px 12px; cursor: pointer; border: 1px solid #e5e7eb; border-bottom: none; border-radius: 8px 8px 0 0; background: #e5e7eb; }
    .tab.active { background: white; font-weight: 600; }
    .panel { border-top: 1px solid #e5e7eb; display: none; }
    .panel.active { display: block; }
    .container { display: grid; grid-template-columns: 360px 1fr; height: calc(100vh - 96px); }
    .sidebar { border-right: 1px solid #e5e7eb; overflow: auto; padding: 8px; }
    .main { overflow: auto; padding: 8px; }
    .search { width: 100%; padding: 8px; margin-bottom: 8px; }
    ul { list-style: none; padding: 0; margin: 0; }
    li { padding: 4px 6px; cursor: pointer; border-radius: 4px; }
    li:hover { background: #f3f4f6; }
    .path { color: #6b7280; font-size: 12px; }
    .graph { border: 1px solid #e5e7eb; min-height: 480px; background: white; }
    .loading { color: #6b7280; }
    .error { color: #b91c1c; }
  .controls { margin-bottom: 8px; display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
  .legend { display:flex; align-items:center; gap:12px; color:#374151; font-size:13px; }
  .chip { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid #e5e7eb; border-radius:999px; background:#f9fafb; }
  .dot { width:12px; height:12px; border-radius:999px; display:inline-block; }
  .line { width:20px; height:0; border-top:3px solid; display:inline-block; position:relative; }
  .line.arrow::after { content:'>'; position:absolute; right:-6px; top:-8px; font-weight:bold; }
  .line.tee::after { content:''; position:absolute; right:-2px; top:-6px; width:0; height:0; border-left:8px solid currentColor; border-top:6px solid transparent; border-bottom:6px solid transparent; transform: rotate(90deg); }
  .toggle { display:inline-flex; gap:6px; align-items:center; cursor:pointer; user-select:none; }
  .toggle input { accent-color:#0b3d91; }
  .sublist { margin: 6px 0 8px; padding: 6px; border: 1px solid #e5e7eb; border-radius: 8px; background: #f9fafb; max-height: 200px; overflow: auto; }
  .sublist .title { font-size: 12px; color: #6b7280; margin-bottom: 6px; }
  .layout { display:inline-flex; align-items:center; gap:6px; }
  .layout input[type="number"] { width: 64px; padding: 3px 6px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/viz.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/full.render.js"></script>
</head>
<body>
  <header>
    <h1>HRA Graph Viewer</h1>
  </header>
  <div class="tabs">
    <div class="tab active" data-target="#tab-canonical">Canonical (hras_dot_files)</div>
    <div class="tab" data-target="#tab-outputs">Outputs (hra_evolution_results)</div>
  </div>
  <div class="panel active" id="tab-canonical">
    <div class="container">
      <div class="sidebar">
        <input class="search" id="search-canon" placeholder="Filter by filename..." />
        <ul id="list-canon"></ul>
      </div>
      <div class="main">
        <div class="controls">
          <span class="loading" id="status-canon">Loading index...</span>
          <label class="toggle"><input type="checkbox" id="raw-canon"> Show raw DOT</label>
          <span class="layout">
            <label>Layout
              <select id="layout-canon">
                <option value="dot" selected>dot</option>
                <option value="neato">neato</option>
                <option value="sfdp">sfdp</option>
                <option value="twopi">twopi</option>
                <option value="circo">circo</option>
              </select>
            </label>
            <label>nodesep <input type="number" step="0.1" id="nodesep-canon" value="0.6"></label>
            <label>ranksep <input type="number" step="0.1" id="ranksep-canon" value="0.9"></label>
          </span>
          <div class="legend">
            <span class="chip"><span class="dot" style="background:#000"></span>regulator</span>
            <span class="chip"><span class="dot" style="background:#2563eb"></span>no output</span>
            <span class="chip"><span class="line arrow" style="border-color:#22c55e"></span>positive (label=0)</span>
            <span class="chip"><span class="line tee" style="border-color:#c026d3"></span>negative (label=1)</span>
          </div>
        </div>
        <div class="sublist" id="sublist-canon">
          <div class="title">Graphs in file</div>
          <ul id="filegraphs-canon"></ul>
        </div>
        <div id="graph-canon" class="graph"></div>
      </div>
    </div>
  </div>
  <div class="panel" id="tab-outputs">
    <div class="container">
      <div class="sidebar">
        <input class="search" id="search-out" placeholder="Filter by filename..." />
        <ul id="list-out"></ul>
      </div>
      <div class="main">
        <div class="controls">
          <span class="loading" id="status-out">Loading index...</span>
          <label class="toggle"><input type="checkbox" id="raw-out"> Show raw DOT</label>
          <span class="layout">
            <label>Layout
              <select id="layout-out">
                <option value="dot">dot</option>
                <option value="neato">neato</option>
                <option value="sfdp" selected>sfdp</option>
                <option value="twopi">twopi</option>
                <option value="circo">circo</option>
              </select>
            </label>
            <label>nodesep <input type="number" step="0.1" id="nodesep-out" value="0.9"></label>
            <label>ranksep <input type="number" step="0.1" id="ranksep-out" value="1.2"></label>
          </span>
          <div class="legend">
            <span class="chip"><span class="dot" style="background:#000"></span>regulator</span>
            <span class="chip"><span class="dot" style="background:#2563eb"></span>no output</span>
            <span class="chip"><span class="line arrow" style="border-color:#22c55e"></span>positive (label=0)</span>
            <span class="chip"><span class="line tee" style="border-color:#c026d3"></span>negative (label=1)</span>
          </div>
        </div>
        <div class="sublist" id="sublist-out">
          <div class="title">Graphs in file</div>
          <ul id="filegraphs-out"></ul>
        </div>
        <div id="graph-out" class="graph"></div>
      </div>
    </div>
  </div>
  <script>
    function setupTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
          tab.classList.add('active');
          const target = document.querySelector(tab.dataset.target);
          if (target) target.classList.add('active');
        });
      });
    }

    async function loadIndex(path) {
      try {
        const res = await fetch(path);
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return await res.json();
      } catch (e) {
        return { error: e.message };
      }
    }

    function renderList(listEl, statusEl, index, onClick) {
      if (index.error) {
        statusEl.textContent = 'Failed to load index: ' + index.error;
        statusEl.className = 'error';
        return;
      }
      statusEl.textContent = 'Loaded ' + index.length + ' files';
      statusEl.className = 'loading';
      const frag = document.createDocumentFragment();
      index.sort();
      index.forEach(p => {
        const li = document.createElement('li');
        li.innerHTML = `<div>${p.split('/').pop()}</div><div class="path">${p}</div>`;
        li.addEventListener('click', () => onClick(p));
        frag.appendChild(li);
      });
      listEl.innerHTML = '';
      listEl.appendChild(frag);
    }

    function getLayoutSettings(prefix) {
      const engine = document.getElementById(`layout-${prefix}`)?.value || 'dot';
      const nodesep = parseFloat(document.getElementById(`nodesep-${prefix}`)?.value || '0.6');
      const ranksep = parseFloat(document.getElementById(`ranksep-${prefix}`)?.value || '0.9');
      return { engine, nodesep, ranksep };
    }

    function preprocessDot(dot, opts) {
      const header = [
        `  graph [rankdir=LR, splines=true, overlap=false, pad=0.2, nodesep=${(opts?.nodesep ?? 0.6).toFixed(2)}, ranksep=${(opts?.ranksep ?? 0.9).toFixed(2)}];`,
        '  node [shape=circle, style=filled, fillcolor="#000000", fontcolor="white", fontsize=12, width=0.35, height=0.35, margin=0.02];',
        '  edge [color="#22c55e", penwidth=2, arrowsize=0.9, arrowhead="normal", minlen=1];'
      ].join('\n');

      let out = dot.replace(/(digraph\s+[^\{]+\{)/g, (m) => m + '\n' + header + '\n');

      const edges = [];
      const edgeRe = /\n\s*(\d+)\s*->\s*(\d+)\s*\[(.*?)\];/g;
      let match;
      while ((match = edgeRe.exec(out)) !== null) {
        const from = parseInt(match[1], 10);
        const to = parseInt(match[2], 10);
        const attrs = match[3];
        const labelMatch = attrs.match(/label\s*=\s*"([01])"/);
        const label = labelMatch ? labelMatch[1] : null;
        edges.push({ from, to, label, whole: match[0] });
      }

      for (const e of edges) {
        let replacementAttrs;
        if (e.label === '0') {
          replacementAttrs = 'color="#22c55e", arrowhead="normal"';
        } else if (e.label === '1') {
          replacementAttrs = 'color="#c026d3", arrowhead="tee"';
        } else {
          replacementAttrs = 'color="#9ca3af", arrowhead="normal"';
        }
        const newLine = `\n  ${e.from} -> ${e.to} [${replacementAttrs}];`;
        out = out.replace(e.whole, newLine);
      }

      const outdeg = new Map();
      for (const e of edges) {
        outdeg.set(e.from, (outdeg.get(e.from) || 0) + 1);
        if (!outdeg.has(e.to)) outdeg.set(e.to, outdeg.get(e.to) || 0);
      }
      if (edges.length > 0) {
        const nodes = Array.from(outdeg.keys()).sort((a,b)=>a-b);
        const nodeLines = nodes.map(n => {
          const hasOut = (outdeg.get(n) || 0) > 0;
          const fill = hasOut ? '#000000' : '#2563eb';
          return `  ${n} [fillcolor="${fill}"];`;
        }).join('\n');
        out = out.replace(/(digraph\s+[^\{]+\{[^]*?)(\n\s*\})/g, (m, pre, close) => pre + '\n' + nodeLines + '\n' + close);
      }
      return out;
    }

  async function renderDot(targetEl, statusEl, path, rawCheckbox, opts) {
      statusEl.textContent = 'Loading ' + path + '...';
      statusEl.className = 'loading';
      try {
        const res = await fetch(path);
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const dot = await res.text();
        const viz = new Viz();
    const toRender = rawCheckbox && rawCheckbox.checked ? dot : preprocessDot(dot, opts);
    const svg = await viz.renderSVGElement(toRender, { engine: (opts?.engine || 'dot') });
        targetEl.innerHTML = '';
        targetEl.appendChild(svg);
        statusEl.textContent = 'Rendered ' + path;
      } catch (e) {
        targetEl.innerHTML = '';
        statusEl.textContent = 'Failed to render ' + path + ': ' + e.message + '. Is Graphviz syntax valid?';
        statusEl.className = 'error';
      }
    }

    // Split a DOT file into individual digraph blocks and attach nearby comments as title
    function splitDotFile(text) {
      const lines = text.split(/\r?\n/);
      const blocks = [];
      let i = 0;
      while (i < lines.length) {
        // skip until a digraph line
        if (!/\bdigraph\b/.test(lines[i])) { i++; continue; }
        const startIdx = i;
        // Collect contiguous comment lines immediately above start (if any)
        let comments = [];
        for (let j = startIdx - 1; j >= 0; j--) {
          const s = lines[j].trim();
          if (s.startsWith('//')) { comments.unshift(lines[j]); continue; }
          if (s === '') { continue; }
          break;
        }
        // Parse name
        const nameMatch = lines[i].match(/digraph\s+([^\s{]+)/);
        const name = nameMatch ? nameMatch[1] : `graph_${blocks.length+1}`;
        // Capture until matching closing brace
        let depth = 0; let captured = [];
        while (i < lines.length) {
          const line = lines[i];
          if (line.includes('{')) depth += (line.match(/\{/g) || []).length;
          if (line.includes('}')) depth -= (line.match(/\}/g) || []).length;
          captured.push(line);
          i++;
          if (depth === 0 && /\}/.test(line)) break;
        }
        const blockText = captured.join('\n');
        const title = comments.length ? `${name} — ${comments.join(' ').replace(/\/\//g,'').trim()}` : name;
        blocks.push({ title, dot: blockText });
      }
      return blocks;
    }

    // Populate the per-file graph list and render the first one
  function populateFileGraphs(listEl, statusEl, targetEl, rawCheckbox, blocks, optsProvider, remember) {
      listEl.innerHTML = '';
      if (!blocks || !blocks.length) {
        statusEl.textContent = 'No digraphs found in file';
        return;
      }
      const frag = document.createDocumentFragment();
      blocks.forEach((b, idx) => {
        const li = document.createElement('li');
        li.textContent = `${idx+1}. ${b.title}`;
        li.addEventListener('click', async () => {
      remember.current = b.dot;
      await renderDotString(targetEl, statusEl, b.dot, rawCheckbox, optsProvider());
        });
        frag.appendChild(li);
      });
      listEl.appendChild(frag);
      // Render the first by default
    remember.current = blocks[0].dot;
    renderDotString(targetEl, statusEl, blocks[0].dot, rawCheckbox, optsProvider());
    }

    // Render a single digraph block string
  async function renderDotString(targetEl, statusEl, dotBlock, rawCheckbox, opts) {
      statusEl.textContent = 'Rendering selected graph...';
      statusEl.className = 'loading';
      try {
        const viz = new Viz();
    const toRender = rawCheckbox && rawCheckbox.checked ? dotBlock : preprocessDot(dotBlock, opts);
    const svg = await viz.renderSVGElement(toRender, { engine: (opts?.engine || 'dot') });
        targetEl.innerHTML = '';
        targetEl.appendChild(svg);
        statusEl.textContent = 'Rendered';
      } catch (e) {
        targetEl.innerHTML = '';
        statusEl.textContent = 'Failed to render graph: ' + e.message;
        statusEl.className = 'error';
      }
    }

    function hookFilter(inputEl, listEl) {
      inputEl.addEventListener('input', () => {
        const q = inputEl.value.toLowerCase();
        listEl.querySelectorAll('li').forEach(li => {
          const text = li.textContent.toLowerCase();
          li.style.display = text.includes(q) ? '' : 'none';
        });
      });
    }

    async function init() {
      setupTabs();
      const statusCanon = document.getElementById('status-canon');
      const statusOut = document.getElementById('status-out');
      const listCanon = document.getElementById('list-canon');
      const listOut = document.getElementById('list-out');
      const graphCanon = document.getElementById('graph-canon');
      const graphOut = document.getElementById('graph-out');
      const idxCanon = await loadIndex('graph_parser/hras_dot_files/index.json');
      const idxOut = await loadIndex('graph_parser/hra_evolution_results/index.json');
      const rawCanon = document.getElementById('raw-canon');
      const rawOut = document.getElementById('raw-out');
      const fileGraphsCanon = document.getElementById('filegraphs-canon');
      const fileGraphsOut = document.getElementById('filegraphs-out');
      const rememberCanon = { current: null };
      const rememberOut = { current: null };

      renderList(listCanon, statusCanon, idxCanon, async (p) => {
        statusCanon.textContent = 'Loading ' + p + '...';
        const res = await fetch(p);
        const text = await res.text();
        const blocks = splitDotFile(text);
        const optsProvider = () => ({ ...getLayoutSettings('canon') });
        populateFileGraphs(fileGraphsCanon, statusCanon, graphCanon, rawCanon, blocks, optsProvider, rememberCanon);
      });

      renderList(listOut, statusOut, idxOut, async (p) => {
        statusOut.textContent = 'Loading ' + p + '...';
        const res = await fetch(p);
        const text = await res.text();
        const blocks = splitDotFile(text);
        const optsProvider = () => ({ ...getLayoutSettings('out') });
        populateFileGraphs(fileGraphsOut, statusOut, graphOut, rawOut, blocks, optsProvider, rememberOut);
      });
      hookFilter(document.getElementById('search-canon'), listCanon);
      hookFilter(document.getElementById('search-out'), listOut);

      // Re-render last selection on layout changes
      ['layout-canon','nodesep-canon','ranksep-canon','layout-out','nodesep-out','ranksep-out','raw-canon','raw-out']
        .forEach(id => {
          const el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('change', () => {
            if (id.includes('canon') && rememberCanon.current) {
              renderDotString(graphCanon, statusCanon, rememberCanon.current, rawCanon, getLayoutSettings('canon'));
            }
            if (id.includes('out') && rememberOut.current) {
              renderDotString(graphOut, statusOut, rememberOut.current, rawOut, getLayoutSettings('out'));
            }
          });
        });
    }
    init();
  </script>
</body>
</html>
